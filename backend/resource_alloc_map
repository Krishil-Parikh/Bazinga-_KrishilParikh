import pandas as pd
import numpy as np
import pulp as pl
from datetime import datetime
import matplotlib.pyplot as plt
import seaborn as sns
import folium
from folium.plugins import MarkerCluster
import plotly.express as px
import plotly.graph_objects as go
from transformers import pipeline

class HealthcareResourceAllocator:
    def __init__(self, patients_file, hospitals_file, suppliers_file, use_llm=False):
        """Initialize the resource allocator with data files."""
        self.patients_df = pd.read_csv(patients_file)
        self.hospitals_df = pd.read_csv(hospitals_file)
        self.suppliers_df = pd.read_csv(suppliers_file)
        self.allocation_results = None
        self.use_llm = use_llm
        
        # Initialize LLM if requested
        if self.use_llm:
            try:
                self.nlp = pipeline("text-generation", model="gpt2")
                print("LLM model loaded successfully")
            except Exception as e:
                print(f"Failed to load LLM model: {e}")
                self.use_llm = False
        
        # Preprocess data
        self._preprocess_data()
        
    def _preprocess_data(self):
        """Preprocess and clean the data."""
        # Convert timestamps to datetime
        if 'Time of Arrival' in self.patients_df.columns:
            self.patients_df['Time of Arrival'] = pd.to_datetime(self.patients_df['Time of Arrival'])
        
        if 'Last_Updated' in self.hospitals_df.columns:
            self.hospitals_df['Last_Updated'] = pd.to_datetime(self.hospitals_df['Last_Updated'])
            
        if 'Last_Updated' in self.suppliers_df.columns:
            self.suppliers_df['Last_Updated'] = pd.to_datetime(self.suppliers_df['Last_Updated'])
        
        # Calculate available resources per hospital
        self.hospitals_df['Effective_Beds'] = self.hospitals_df['Beds_Available']
        self.hospitals_df['Effective_Staff'] = self.hospitals_df['Staff_Available']
        
        # Create patient priority score based on available metrics
        # First check column data types and convert if necessary
        if 'Triage Priority' in self.patients_df.columns:
            # Handle case where Triage Priority is a string
            try:
                self.patients_df['Triage Priority'] = pd.to_numeric(self.patients_df['Triage Priority'])
            except (ValueError, TypeError):
                # If conversion fails, create a mapping for string values
                priority_mapping = {'Immediate': 1, 'Emergency': 1, 'Urgent': 2, 'Semi-urgent': 3, 'Non-urgent': 4, 'Minor': 5}
                # Apply with a default value of 3 (middle priority) for any unexpected values
                self.patients_df['Triage_Priority_Numeric'] = self.patients_df['Triage Priority'].map(priority_mapping).fillna(3)
        
        # Same for MEWS Score
        if 'MEWS_Score' in self.patients_df.columns:
            try:
                self.patients_df['MEWS_Score'] = pd.to_numeric(self.patients_df['MEWS_Score'])
            except (ValueError, TypeError):
                # Set default value if conversion fails
                self.patients_df['MEWS_Score'] = 2  # Default moderate score
        
        # Same for Time Criticality
        if 'Time_Criticality_Min' in self.patients_df.columns:
            try:
                self.patients_df['Time_Criticality_Min'] = pd.to_numeric(self.patients_df['Time_Criticality_Min'])
            except (ValueError, TypeError):
                # Set default value if conversion fails
                self.patients_df['Time_Criticality_Min'] = 60  # Default 1 hour
        
        # Now calculate the priority score based on available and properly typed data
        if all(col in self.patients_df.columns for col in ['Triage Priority', 'MEWS_Score', 'Time_Criticality_Min']):
            if 'Triage_Priority_Numeric' in self.patients_df.columns:
                # Use the mapped numeric value
                self.patients_df['Priority_Score'] = (5 - self.patients_df['Triage_Priority_Numeric']) * 5 + \
                                                   self.patients_df['MEWS_Score'] * 2 + \
                                                   (60 / (self.patients_df['Time_Criticality_Min'] + 1))
            else:
                # Use the numeric Triage Priority directly
                self.patients_df['Priority_Score'] = (5 - self.patients_df['Triage Priority']) * 5 + \
                                                   self.patients_df['MEWS_Score'] * 2 + \
                                                   (60 / (self.patients_df['Time_Criticality_Min'] + 1))
        elif 'Derived_Severity' in self.patients_df.columns:
            # Try to use derived severity if other metrics not available
            try:
                self.patients_df['Derived_Severity'] = pd.to_numeric(self.patients_df['Derived_Severity'])
                self.patients_df['Priority_Score'] = self.patients_df['Derived_Severity'] * 10
            except (ValueError, TypeError):
                # If conversion fails, use a simple default score
                self.patients_df['Priority_Score'] = 50  # Middle priority
        else:
            # If no suitable metrics available, assign default values
            self.patients_df['Priority_Score'] = 50  # Middle priority
            self.patients_df['MEWS_Score'] = self.patients_df.get('MEWS_Score', 2)  # Default moderate score
            
        # Check for and add geocoding coordinates if missing
        self._add_geocoding_if_missing()
    
    def _add_geocoding_if_missing(self):
        """Add latitude and longitude to hospitals and suppliers if missing."""
        # Check if hospitals have coordinates
        if not all(col in self.hospitals_df.columns for col in ['Latitude', 'Longitude']):
            # Create a default region column if it doesn't exist
            if 'Region' not in self.hospitals_df.columns:
                self.hospitals_df['Region'] = 'Default'
                
            # Create dummy coordinates based on region for visualization
            regions = self.hospitals_df['Region'].unique()
            region_coords = {}
            
            # Generate some spread-out coordinates for different regions
            for i, region in enumerate(regions):
                # Create a base coordinate with some offset for different regions
                base_lat = 40 + (i * 0.5)  # Starting from latitude 40 with 0.5 increment
                base_lon = -100 + (i * 0.5)  # Starting from longitude -100 with 0.5 increment
                region_coords[region] = (base_lat, base_lon)
            
            # Add base coordinates for each hospital based on region
            self.hospitals_df['Latitude'] = self.hospitals_df['Region'].map(lambda r: region_coords[r][0])
            self.hospitals_df['Longitude'] = self.hospitals_df['Region'].map(lambda r: region_coords[r][1])
            
            # Add small random offset to each hospital in the same region
            # This spreads them out a bit for better visualization
            self.hospitals_df['Latitude'] += np.random.normal(0, 0.05, size=len(self.hospitals_df))
            self.hospitals_df['Longitude'] += np.random.normal(0, 0.05, size=len(self.hospitals_df))
        
        # Do the same for suppliers if needed
        if not all(col in self.suppliers_df.columns for col in ['Latitude', 'Longitude']):
            # Create a default region column if it doesn't exist
            if 'Region' not in self.suppliers_df.columns:
                # Default all suppliers to first region from hospitals if available
                if 'Region' in self.hospitals_df.columns and not self.hospitals_df.empty:
                    default_region = self.hospitals_df['Region'].iloc[0]
                else:
                    default_region = 'Default'
                self.suppliers_df['Region'] = default_region
            
            regions = self.suppliers_df['Region'].unique()
            region_coords = {}
            
            for i, region in enumerate(regions):
                base_lat = 40 + (i * 0.5)
                base_lon = -100 + (i * 0.5)
                region_coords[region] = (base_lat, base_lon)
            
            self.suppliers_df['Latitude'] = self.suppliers_df['Region'].map(lambda r: region_coords.get(r, (40, -100))[0])
            self.suppliers_df['Longitude'] = self.suppliers_df['Region'].map(lambda r: region_coords.get(r, (40, -100))[1])
            
            self.suppliers_df['Latitude'] += np.random.normal(0, 0.05, size=len(self.suppliers_df))
            self.suppliers_df['Longitude'] += np.random.normal(0, 0.05, size=len(self.suppliers_df))
    
    def optimize_allocation(self):
        """Run the optimization model to allocate patients to hospitals."""
        # Create optimization problem
        model = pl.LpProblem("Healthcare_Resource_Allocation", pl.LpMaximize)
        
        # Get relevant data
        patients = self.patients_df
        hospitals = self.hospitals_df
        
        # Ensure 'Region' column exists in patients DataFrame
        if 'Region' not in patients.columns:
            # Default all patients to first region if missing
            default_region = hospitals['Region'].iloc[0] if not hospitals.empty else "Unknown"
            patients['Region'] = default_region
        
        # Create decision variables
        # x[i,j] = 1 if patient i is assigned to hospital j, 0 otherwise
        x = pl.LpVariable.dicts("patient_assignment", 
                              [(i, j) for i in patients.index for j in hospitals.index],
                              cat=pl.LpBinary)
        
        # Objective function: Maximize weighted sum of patient-hospital assignments
        # Weight includes patient priority and regional matching
        objective = pl.lpSum([x[i,j] * patients.loc[i, 'Priority_Score'] * 
                            (2 if patients.loc[i, 'Region'] == hospitals.loc[j, 'Region'] else 1)
                            for i in patients.index for j in hospitals.index])
        model += objective
        
        # Constraint 1: Each patient is assigned to at most one hospital
        for i in patients.index:
            model += pl.lpSum([x[i,j] for j in hospitals.index]) <= 1
        
        # Constraint 2: Hospital bed capacity
        for j in hospitals.index:
            model += pl.lpSum([x[i,j] for i in patients.index]) <= hospitals.loc[j, 'Effective_Beds']
        
        # Constraint 3: Hospital staff capacity
        # Assume each patient needs 0.5 staff members on average
        if 'Effective_Staff' in hospitals.columns:
            for j in hospitals.index:
                model += pl.lpSum([x[i,j] * 0.5 for i in patients.index]) <= hospitals.loc[j, 'Effective_Staff']
        
        # Constraint 4: Ensure hospitals have necessary equipment for critical patients
        # For critical patients (MEWS >= 5), ensure ventilator availability
        if 'MEWS_Score' in patients.columns and 'Ventilators' in hospitals.columns:
            critical_patients = [i for i in patients.index if patients.loc[i, 'MEWS_Score'] >= 5]
            for j in hospitals.index:
                model += pl.lpSum([x[i,j] for i in critical_patients]) <= hospitals.loc[j, 'Ventilators']
        
        # Solve the model
        model.solve()
        
        # Extract results
        allocation_results = []
        for i in patients.index:
            assigned_hospital = None
            for j in hospitals.index:
                if pl.value(x[i,j]) == 1:
                    assigned_hospital = j
                    break
            
            result_row = {
                'Patient_ID': patients.loc[i, 'Patient ID'] if 'Patient ID' in patients.columns else i,
                'Patient_Name': patients.loc[i, 'Patient Name'] if 'Patient Name' in patients.columns else f"Patient_{i}",
                'Priority_Score': patients.loc[i, 'Priority_Score'],
                'Patient_Region': patients.loc[i, 'Region']
            }
            
            # Add MEWS Score if available
            if 'MEWS_Score' in patients.columns:
                result_row['MEWS_Score'] = patients.loc[i, 'MEWS_Score']
            
            if assigned_hospital is not None:
                result_row.update({
                    'Assigned_Hospital': hospitals.loc[assigned_hospital, 'Name'] if 'Name' in hospitals.columns else f"Hospital_{assigned_hospital}",
                    'Hospital_Region': hospitals.loc[assigned_hospital, 'Region'],
                    'Is_Regional_Match': patients.loc[i, 'Region'] == hospitals.loc[assigned_hospital, 'Region']
                })
            else:
                result_row.update({
                    'Assigned_Hospital': 'Unassigned',
                    'Hospital_Region': None,
                    'Is_Regional_Match': False
                })
                
            allocation_results.append(result_row)
        
        self.allocation_results = pd.DataFrame(allocation_results)
        
        # Use LLM to generate commentary if enabled
        if self.use_llm:
            self._generate_llm_insights()
            
        return self.allocation_results
    
    def _generate_llm_insights(self):
        """Use LLM to generate insights about the allocation results."""
        if not self.use_llm or self.allocation_results is None:
            return
        
        try:
            # Create a summary of allocation results
            total = len(self.allocation_results)
            assigned = sum(self.allocation_results['Assigned_Hospital'] != 'Unassigned')
            regional_matches = sum(self.allocation_results['Is_Regional_Match'])
            
            prompt = f"""
            Analyze the following healthcare resource allocation results:
            - Total patients: {total}
            - Assigned patients: {assigned} ({assigned/total*100:.1f}%)
            - Regional matches: {regional_matches} ({regional_matches/assigned*100:.1f}% of assigned)
            
            Provide 3 key insights about this allocation and 2 recommendations for improvement.
            """
            
            # Generate insights using LLM
            insights = self.nlp(prompt, max_length=300, num_return_sequences=1)[0]['generated_text']
            
            # Store insights for later use
            self.llm_insights = insights
            print("LLM insights generated successfully")
        except Exception as e:
            print(f"Failed to generate LLM insights: {e}")
            self.llm_insights = "LLM analysis unavailable."
    
    def allocate_supplier_resources(self):
        """Allocate supplier resources to hospitals based on need."""
        if self.allocation_results is None:
            raise ValueError("Must run optimize_allocation() first")
        
        # Check if supplier data exists
        if self.suppliers_df.empty:
            return pd.DataFrame()  # Return empty DataFrame if no suppliers
        
        # Create optimization problem
        model = pl.LpProblem("Supplier_Resource_Allocation", pl.LpMinimize)
        
        hospitals = self.hospitals_df
        suppliers = self.suppliers_df
        
        # Ensure 'Name' column exists in hospitals DataFrame
        if 'Name' not in hospitals.columns:
            hospitals['Name'] = [f"Hospital_{i}" for i in hospitals.index]
            
        # Ensure 'Region' column exists in suppliers DataFrame
        if 'Region' not in suppliers.columns:
            # Default all suppliers to first region if missing
            default_region = hospitals['Region'].iloc[0] if not hospitals.empty else "Unknown"
            suppliers['Region'] = default_region
        
        # Calculate hospital needs based on patient allocation
        hospital_patient_counts = self.allocation_results['Assigned_Hospital'].value_counts()
        hospitals['Additional_Patients'] = hospitals['Name'].map(hospital_patient_counts).fillna(0)
        
        # Estimate additional resources needed
        hospitals['Additional_Beds_Needed'] = hospitals['Additional_Patients']
        hospitals['Additional_Staff_Needed'] = hospitals['Additional_Patients'] * 0.5
        hospitals['Additional_Medical_Kits_Needed'] = hospitals['Additional_Patients']
        
        # Check what resources are available from suppliers
        available_resources = []
        if 'Beds' in suppliers.columns:
            available_resources.append('Beds')
        if 'Staff' in suppliers.columns:
            available_resources.append('Staff')
        if 'Medical_Kits' in suppliers.columns:
            available_resources.append('Medical_Kits')
            
        # If no resources available, return empty DataFrame
        if not available_resources:
            return pd.DataFrame()
        
        # Create decision variables
        # y[s,h,r] = amount of resource r from supplier s to hospital h
        y = {}
        for s in suppliers.index:
            for h in hospitals.index:
                for r in available_resources:
                    y[s,h,r] = pl.LpVariable(f"supply_{s}_{h}_{r}", lowBound=0, cat=pl.LpInteger)
        
        # Objective: Minimize transportation costs (approximated by distance)
        # Assume distances are related to whether supplier and hospital are in same region
        transportation_cost = pl.lpSum([y[s,h,r] * 
                                     (1 if suppliers.loc[s, 'Region'] == hospitals.loc[h, 'Region'] else 3)
                                     for s in suppliers.index 
                                     for h in hospitals.index 
                                     for r in available_resources])
        model += transportation_cost
        
        # Constraint 1: Supplier capacity
        for s in suppliers.index:
            for r in available_resources:
                model += pl.lpSum([y[s,h,r] for h in hospitals.index]) <= suppliers.loc[s, r]
        
        # Constraint 2: Hospital needs
        for h in hospitals.index:
            if 'Beds' in available_resources:
                model += pl.lpSum([y[s,h,'Beds'] for s in suppliers.index]) >= hospitals.loc[h, 'Additional_Beds_Needed']
            if 'Staff' in available_resources:
                model += pl.lpSum([y[s,h,'Staff'] for s in suppliers.index]) >= hospitals.loc[h, 'Additional_Staff_Needed']
            if 'Medical_Kits' in available_resources:
                model += pl.lpSum([y[s,h,'Medical_Kits'] for s in suppliers.index]) >= hospitals.loc[h, 'Additional_Medical_Kits_Needed']
        
        # Solve the model
        model.solve(pl.PULP_CBC_CMD(msg=False))
        
        # Extract results
        supply_results = []
        for s in suppliers.index:
            for h in hospitals.index:
                for r in available_resources:
                    if pl.value(y[s,h,r]) > 0:
                        supply_results.append({
                            'Supplier_ID': suppliers.loc[s, 'Supplier_ID'] if 'Supplier_ID' in suppliers.columns else f"Supplier_{s}",
                            'Hospital': hospitals.loc[h, 'Name'],
                            'Resource': r,
                            'Amount': pl.value(y[s,h,r]),
                            'Is_Regional_Match': suppliers.loc[s, 'Region'] == hospitals.loc[h, 'Region']
                        })
        
        self.supply_results = pd.DataFrame(supply_results)
        return self.supply_results
    
    def generate_reports(self):
        """Generate summary reports of the allocation results."""
        if self.allocation_results is None:
            raise ValueError("Must run optimize_allocation() first")
        
        # Patient allocation summary
        patient_summary = {
            'Total_Patients': len(self.allocation_results),
            'Assigned_Patients': sum(self.allocation_results['Assigned_Hospital'] != 'Unassigned'),
            'Unassigned_Patients': sum(self.allocation_results['Assigned_Hospital'] == 'Unassigned'),
            'Regional_Matches': sum(self.allocation_results['Is_Regional_Match']),
            'Average_Priority_Score': self.allocation_results['Priority_Score'].mean()
        }
        
        # Add MEWS stats if available
        if 'MEWS_Score' in self.allocation_results.columns:
            patient_summary['High_MEWS_Patients'] = sum(self.allocation_results['MEWS_Score'] >= 5)
        
        # Hospital utilization
        hospital_counts = self.allocation_results['Assigned_Hospital'].value_counts().to_dict()
        hospital_util = {}
        
        for h in self.hospitals_df.index:
            name = self.hospitals_df.loc[h, 'Name'] if 'Name' in self.hospitals_df.columns else f"Hospital_{h}"
            
            # Get capacity if available
            if 'Beds_Capacity' in self.hospitals_df.columns:
                capacity = self.hospitals_df.loc[h, 'Beds_Capacity']
            else:
                capacity = self.hospitals_df.loc[h, 'Beds_Available'] if 'Beds_Available' in self.hospitals_df.columns else 0
            
            # Get current patients if available
            if 'Current_Patients' in self.hospitals_df.columns:
                current = self.hospitals_df.loc[h, 'Current_Patients']
            else:
                current = 0
                
            assigned = hospital_counts.get(name, 0)
            util_pct = (current + assigned) / capacity * 100 if capacity > 0 else 0
            
            hospital_util[name] = {
                'Capacity': capacity,
                'Current_Patients': current,
                'Newly_Assigned': assigned,
                'Utilization_Percent': util_pct
            }
        
        # Add LLM insights if available
        if self.use_llm and hasattr(self, 'llm_insights'):
            llm_analysis = self.llm_insights
        else:
            llm_analysis = None
        
        return {
            'patient_summary': patient_summary,
            'hospital_utilization': hospital_util,
            'llm_analysis': llm_analysis
        }
    
    def visualize_allocation(self):
        """Create visualizations of the allocation results."""
        if self.allocation_results is None:
            raise ValueError("Must run optimize_allocation() first")
        
        # Check if visualization dependencies are available
        try:
            import matplotlib.pyplot as plt
            import seaborn as sns
        except ImportError:
            print("Visualization dependencies (matplotlib, seaborn) not available.")
            return None
        
        # Create a figure with multiple subplots
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        
        # 1. Patient assignment by hospital
        hospital_counts = self.allocation_results['Assigned_Hospital'].value_counts()
        sns.barplot(x=hospital_counts.index, y=hospital_counts.values, ax=axes[0,0])
        axes[0,0].set_title('Patient Assignments by Hospital')
        axes[0,0].set_xticklabels(axes[0,0].get_xticklabels(), rotation=45, ha='right')
        
        # 2. Assignment by patient region
        region_counts = self.allocation_results.groupby('Patient_Region')['Assigned_Hospital'].apply(
            lambda x: sum(x != 'Unassigned')).reset_index()
        region_counts.columns = ['Region', 'Assigned Patients']
        sns.barplot(x='Region', y='Assigned Patients', data=region_counts, ax=axes[0,1])
        axes[0,1].set_title('Patient Assignments by Region')
        
        # 3. Regional match percentage
        match_pct = self.allocation_results[self.allocation_results['Assigned_Hospital'] != 'Unassigned']
        if not match_pct.empty:
            match_pct = match_pct.groupby('Patient_Region')['Is_Regional_Match'].mean() * 100
            match_pct = match_pct.reset_index()
            match_pct.columns = ['Region', 'Regional Match Percentage']
            sns.barplot(x='Region', y='Regional Match Percentage', data=match_pct, ax=axes[1,0])
            axes[1,0].set_title('Regional Match Percentage')
        else:
            axes[1,0].set_title('No Regional Match Data Available')
        
        # 4. Assignment by MEWS score if available
        if 'MEWS_Score' in self.allocation_results.columns:
            try:
                mews_groups = pd.cut(self.allocation_results['MEWS_Score'], bins=[0, 2, 4, 6, 9], 
                                    labels=['0-2', '3-4', '5-6', '7-9'])
                mews_assigned = self.allocation_results.groupby(mews_groups)['Assigned_Hospital'].apply(
                    lambda x: sum(x != 'Unassigned') / len(x) * 100 if len(x) > 0 else 0).reset_index()
                mews_assigned.columns = ['MEWS Score', 'Percentage Assigned']
                sns.barplot(x='MEWS Score', y='Percentage Assigned', data=mews_assigned, ax=axes[1,1])
                axes[1,1].set_title('Assignment Rate by MEWS Score')
            except:
                axes[1,1].set_title('MEWS Score Analysis Unavailable')
        else:
            axes[1,1].set_title('MEWS Score Data Not Available')
        
        plt.tight_layout()
        return fig
    
    def create_line_graphs(self):
        """Create line graphs to visualize trends in the data."""
        if self.allocation_results is None:
            raise ValueError("Must run optimize_allocation() first")
        
        # Create figures for line graphs
        fig_line, axes_line = plt.subplots(2, 1, figsize=(15, 12))
        
        # 1. Patient Priority Score Distribution
        if 'Assigned_Hospital' in self.allocation_results.columns and 'Priority_Score' in self.allocation_results.columns:
            # Group patients by hospital and calculate average priority score
            hospital_priority = self.allocation_results[self.allocation_results['Assigned_Hospital'] != 'Unassigned']
            hospital_priority = hospital_priority.groupby('Assigned_Hospital')['Priority_Score'].agg(['mean', 'min', 'max']).reset_index()
            
            # Sort by mean priority score for better visualization
            hospital_priority = hospital_priority.sort_values('mean', ascending=False)
            
            # Plot mean with error bars
            axes_line[0].errorbar(
                x=hospital_priority['Assigned_Hospital'],
                y=hospital_priority['mean'],
                yerr=[hospital_priority['mean'] - hospital_priority['min'], 
                     hospital_priority['max'] - hospital_priority['mean']],
                fmt='o-', capsize=5
            )
            axes_line[0].set_title('Patient Priority Score by Hospital')
            axes_line[0].set_ylabel('Priority Score')
            axes_line[0].set_xlabel('Hospital')
            axes_line[0].set_xticklabels(axes_line[0].get_xticklabels(), rotation=45, ha='right')
            
        # 2. Hospital Utilization Percentage
        reports = self.generate_reports()
        hospital_util = reports['hospital_utilization']
        
        hospitals = []
        utilization = []
        capacities = []
        
        for hospital, stats in hospital_util.items():
            hospitals.append(hospital)
            utilization.append(stats['Utilization_Percent'])
            capacities.append(stats['Capacity'])
        
        # Sort by utilization for better visualization
        sorted_indices = np.argsort(utilization)[::-1]  # Descending order
        hospitals = [hospitals[i] for i in sorted_indices]
        utilization = [utilization[i] for i in sorted_indices]
        capacities = [capacities[i] for i in sorted_indices]
        
        # Create a line plot with capacity overlay
        axes_line[1].plot(hospitals, utilization, 'o-', label='Utilization %')
        
        # Add capacity reference as a secondary axis
        ax2 = axes_line[1].twinx()
        ax2.bar(hospitals, capacities, alpha=0.2, label='Capacity', color='gray')
        ax2.set_ylabel('Bed Capacity')
        
        # Set labels and titles
        axes_line[1].set_title('Hospital Utilization Percentage')
        axes_line[1].set_ylabel('Utilization %')
        axes_line[1].set_xlabel('Hospital')
        axes_line[1].set_xticklabels(axes_line[1].get_xticklabels(), rotation=45, ha='right')
        
        # Add legends
        axes_line[1].legend(loc='upper left')
        ax2.legend(loc='upper right')
        
        plt.tight_layout()
        return fig_line
    
    def create_map_visualization(self):
        """Create an interactive map visualization of hospitals and patient allocations."""
        # Check if hospitals have location data
        if not all(col in self.hospitals_df.columns for col in ['Latitude', 'Longitude']):
            print("Map visualization not available: Missing location data for hospitals")
            return None
        
        # Create a map centered at the mean coordinates of all hospitals
        center_lat = self.hospitals_df['Latitude'].mean()
        center_lon = self.hospitals_df['Longitude'].mean()
        
        # Create a folium map
        m = folium.Map(location=[center_lat, center_lon], zoom_start=5)
        
        # Create a marker cluster for hospitals
        hospital_cluster = MarkerCluster(name="Hospitals")
        
        # Add hospitals to the map
        for idx, row in self.hospitals_df.iterrows():
            # Calculate utilization if allocation has been run
            if self.allocation_results is not None:
                hospital_name = row['Name'] if 'Name' in self.hospitals_df.columns else f"Hospital_{idx}"
                assigned_count = sum(self.allocation_results['Assigned_Hospital'] == hospital_name)
                
                capacity = row['Beds_Available'] if 'Beds_Available' in self.hospitals_df.columns else 100
                current = row['Current_Patients'] if 'Current_Patients' in self.hospitals_df.columns else 0
                
                utilization = (current + assigned_count) / capacity * 100 if capacity > 0 else 0
                utilization_str = f"{utilization:.1f}%"
                
                # Color based on utilization
                if utilization < 50:
                    color = 'green'
                elif utilization < 80:
                    color = 'orange'
                else:
                    color = 'red'
                
                popup_text = f"""
                <b>{hospital_name}</b><br>
                Region: {row['Region']}<br>
                Capacity: {capacity}<br>
                Current Patients: {current}<br>
                Newly Assigned: {assigned_count}<br>
                Utilization: {utilization_str}
                """
            else:
                hospital_name = row['Name'] if 'Name' in self.hospitals_df.columns else f"Hospital_{idx}"
                capacity = row['Beds_Available'] if 'Beds_Available' in self.hospitals_df.columns else 100
                color = 'blue'
                
                popup_text = f"""
                <b>{hospital_name}</b><br>
                Region: {row['Region']}<br>
                Capacity: {capacity}<br>
                """
            
            # Create a popup for this hospital
            popup = folium.Popup(popup_text, max_width=300)
            
            # Create a marker for this hospital
            hospital_marker = folium.Marker(
                location=[row['Latitude'], row['Longitude']],
                popup=popup,
                icon=folium.Icon(color=color, icon='hospital', prefix='fa')
            )
            
            # Add marker to the cluster
            hospital_cluster.add_child(hospital_marker)
        
        # Add suppliers to the map if available
        if not self.suppliers_df.empty and all(col in self.suppliers_df.columns for col in ['Latitude', 'Longitude']):
            supplier_cluster = MarkerCluster(name="Suppliers")
            
            for idx, row in self.suppliers_df.iterrows():
                supplier_name = row['Supplier_Name'] if 'Supplier_Name' in self.suppliers_df.columns else f"Supplier_{idx}"
                
                # Create popup text
                popup_text = f"""
                <b>{supplier_name}</b><br>
                Region: {row['Region']}<br>
                """
                
                # Add resource information if available
                if 'Beds' in self.suppliers_df.columns:
                    popup_text += f"Beds: {row['Beds']}<br>"
                if 'Staff' in self.suppliers_df.columns:
                    popup_text += f"Staff: {row['Staff']}<br>"
                if 'Medical_Kits' in self.suppliers_df.columns:
                    popup_text += f"Medical Kits: {row['Medical_Kits']}<br>"
                
                # Create a popup for this supplier
                popup = folium.Popup(popup_text, max_width=300)
                
                # Create a marker for this supplier
                supplier_marker = folium.Marker(
                    location=[row['Latitude'], row['Longitude']],
                    popup=popup,
                    icon=folium.Icon(color='green', icon='medkit', prefix='fa')
                )
                
                # Add marker to the cluster
                supplier_cluster.add_child(supplier_marker)
            
            # Add supplier cluster to the map
            m.add_child(supplier_cluster)
        
        # Add hospital cluster to the map
        m.add_child(hospital_cluster)
        
        # Add layer control to toggle different layers
        folium.LayerControl().add_to(m)
        
        return m
    
    def create_plotly_visualizations(self):
        """Create interactive Plotly visualizations of the allocation results."""
        if self.allocation_results is None:
            raise ValueError("Must run optimize_allocation() first")
        
        visualizations = {}
        
        # 1. Patient Assignment Sunburst Chart
        if 'Patient_Region' in self.allocation_results.columns and 'Assigned_Hospital' in self.allocation_results.columns:
            # Create a DataFrame for the sunburst chart
            region_hospital = self.allocation_results.groupby(['Patient_Region', 'Assigned_Hospital']).size().reset_index()
            region_hospital.columns = ['Patient_Region', 'Assigned_Hospital', 'Count']
            
            # Create sunburst chart
            fig_sunburst = px.sunburst(
                region_hospital, 
                path=['Patient_Region', 'Assigned_Hospital'], 
                values='Count',
                title='Patient Assignment by Region and Hospital',
                color_discrete_sequence=px.colors.qualitative.Pastel
            )
            visualizations['sunburst'] = fig_sunburst
        
        # 2. Hospital Utilization Gauge Chart
        reports = self.generate_reports()
        hospital_util = reports['hospital_utilization']
        
        # Create a list of gauge charts for each hospital
        gauge_charts = []
        for hospital, stats in hospital_util.items():
            if stats['Capacity'] > 0:  # Avoid division by zero
                fig_gauge = go.Figure(go.Indicator(
                    mode="gauge+number",
                    value=stats['Utilization_Percent'],
                    domain={'x': [0, 1], 'y': [0, 1]},
                    title={'text': hospital},
                    gauge={
                        'axis': {'range': [0, 100]},
                        'bar': {'color': "darkblue"},
                        'steps': [
                            {'range': [0, 50], 'color': "lightgreen"},
                            {'range': [50, 80], 'color': "orange"},
                            {'range': [80, 100], 'color': "red"}
                        ],
                        'threshold': {
                            'line': {'color': "red", 'width': 4},
                            'thickness': 0.75,
                            'value': 90
                        }
                    }
                ))
                gauge_charts.append(fig_gauge)
        
        if gauge_charts:
            visualizations['gauges'] = gauge_charts
        
        # 3. Priority Score Distribution
        if 'Priority_Score' in self.allocation_results.columns:
            fig_hist = px.histogram(
                self.allocation_results,
                x='Priority_Score',
                color='Assigned_Hospital',
                title='Distribution of Priority Scores by Hospital Assignment',
                labels={'Priority_Score': 'Priority Score', 'count': 'Number of Patients'},
                barmode='overlay',
                opacity=0.7
            )
            visualizations['priority_hist'] = fig_hist
        
        # 4. MEWS Score Distribution if available
        if 'MEWS_Score' in self.allocation_results.columns:
            fig_mews = px.histogram(
                self.allocation_results,
                x='MEWS_Score',
                color='Assigned_Hospital',
                title='Distribution of MEWS Scores by Hospital Assignment',
                labels={'MEWS_Score': 'MEWS Score', 'count': 'Number of Patients'},
                barmode='overlay',
                opacity=0.7
            )
            visualizations['mews_hist'] = fig_mews
        
        return visualizations
    
    def export_results(self, filename='allocation_results.csv'):
        """Export allocation results to a CSV file."""
        if self.allocation_results is None:
            raise ValueError("Must run optimize_allocation() first")
        
        self.allocation_results.to_csv(filename, index=False)
        print(f"Results exported to {filename}")
    
    def export_supplier_allocation(self, filename='supplier_allocation.csv'):
        """Export supplier allocation results to a CSV file."""
        if not hasattr(self, 'supply_results') or self.supply_results is None:
            raise ValueError("Must run allocate_supplier_resources() first")
        
        self.supply_results.to_csv(filename, index=False)
        print(f"Supplier allocation results exported to {filename}")

# Example usage
if __name__ == "__main__":
    # Example file paths
    patients_file = "/Users/krishilparikh/Synergy/backend/Triage Flagging/final_synthetic_triage_data.csv"
    hospitals_file = "hospitals.csv"
    suppliers_file = "supplier.csv"
    
    # Create an instance of the allocator
    allocator = HealthcareResourceAllocator(patients_file, hospitals_file, suppliers_file)
    
    # Run optimization
    allocation_results = allocator.optimize_allocation()
    print(f"Allocated {sum(allocation_results['Assigned_Hospital'] != 'Unassigned')} out of {len(allocation_results)} patients")
    
    # Allocate supplier resources
    try:
        supply_results = allocator.allocate_supplier_resources()
        print(f"Generated {len(supply_results)} supplier allocations")
    except Exception as e:
        print(f"Failed to allocate supplier resources: {e}")
    
    # Generate reports
    reports = allocator.generate_reports()
    print("Patient Summary:")
    for key, value in reports['patient_summary'].items():
        print(f"  {key}: {value}")
    
    # Create visualizations
    try:
        plt.close('all')  # Close any existing plots
        fig = allocator.visualize_allocation()
        fig.savefig("allocation_visualization.png")
        print("Saved visualization to allocation_visualization.png")
        
        fig_line = allocator.create_line_graphs()
        fig_line.savefig("allocation_trends.png")
        print("Saved trend graphs to allocation_trends.png")
        
        # Create map visualization
        m = allocator.create_map_visualization()
        if m:
            m.save("allocation_map.html")
            print("Saved interactive map to allocation_map.html")
        
        # Create Plotly visualizations
        plotly_viz = allocator.create_plotly_visualizations()
        if plotly_viz:
            for name, fig in plotly_viz.items():
                if name != 'gauges':  # Handle the special case of multiple gauge charts
                    fig.write_html(f"plotly_{name}.html")
                    print(f"Saved Plotly visualization to plotly_{name}.html")
                else:
                    for i, gauge in enumerate(fig):
                        gauge.write_html(f"plotly_gauge_{i}.html")
                    print(f"Saved {len(fig)} gauge visualizations")
                    
    except Exception as e:
        print(f"Failed to create some visualizations: {e}")
    
    # Export results
    allocator.export_results()
    
    try:
        allocator.export_supplier_allocation()
    except Exception as e:
        print(f"Failed to export supplier allocation: {e}")